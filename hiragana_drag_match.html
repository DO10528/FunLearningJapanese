<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ひらがな単語あわせゲーム</title>
    <!-- フォント等は省略 -->
    <style>
    /* （省略：既存のスタイルをそのまま使用） */
    /* ここに既存の CSS を貼ってください（ユーザーのコードと同じ） */
    </style>
</head>
<body>

    <div id="hg-container">
        <h1 id="hg-main-title">ひらがな単語あわせゲーム</h1>
        
        <div id="hg-level-selection"></div>

        <h2 id="hg-level-title"></h2>
        
        <div id="hg-game-area" style="display: none;">
            <div id="hg-illust-area">
                <h3>イラスト (ドラッグしてね)</h3>
                <div id="hg-illust-pool"></div>
            </div>
            
            <div id="hg-word-area">
                <h3>ことば (ドロップするばしょ)</h3>
                <div id="hg-word-list"></div>
            </div>
        </div>

        <div id="hg-feedback"></div>

        <div class="hg-button-area">
            <button id="hg-reset-placed-button" class="hg-button hg-button-reset" style="display: none;">イラストをもどす</button>
            <button id="hg-home-button" class="hg-button hg-button-home">ホームにもどる</button>
        </div>
    </div>

    <audio id="hg-sound-correct" src="assets/sounds/seikai.mp3" preload="auto"></audio>
    <audio id="hg-sound-incorrect" src="assets/sounds/bubu.mp3" preload="auto"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // 定数（index.html と同じキー名を使う）
            const GAME_ID = 'hiragana_drag_match'; 
            const USER_STORAGE_KEY = 'user_accounts';
            const SESSION_STORAGE_KEY = 'current_user';
            const GUEST_NAME = 'ゲスト';
            
            // ユーティリティ（index.html と合わせる）
            function getUsers() {
                const usersJson = localStorage.getItem(USER_STORAGE_KEY);
                return usersJson ? JSON.parse(usersJson) : {};
            }
            function saveUsers(users) {
                localStorage.setItem(USER_STORAGE_KEY, JSON.stringify(users));
            }
            function getCurrentUser() {
                const currentUser = sessionStorage.getItem(SESSION_STORAGE_KEY);
                return (currentUser && currentUser !== GUEST_NAME) ? currentUser : null;
            }
            function getTodayDateString() {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            // checkAndRecordScore: レベルごとに「1日1ポイント」ルールを担う
            // 戻り値: { status: 'no_user' | 'already' | 'awarded' | 'failed' }
            function checkAndRecordScore(level) {
                const currentUser = getCurrentUser();
                if (!currentUser) {
                    // 未ログイン or ゲスト
                    return { status: 'no_user' };
                }

                const users = getUsers();
                const user = users[currentUser];
                if (!user) return { status: 'failed' };

                const todayStr = getTodayDateString();
                const levelKey = `${GAME_ID}_L${level}`;

                user.progress = user.progress || {};
                user.progress[levelKey] = user.progress[levelKey] || {};

                if (user.progress[levelKey][todayStr] === true) {
                    // 既に今日付与済み
                    return { status: 'already' };
                }

                // ここで addPoints を呼んで実際にポイント付与を試みる
                if (typeof window.addPoints === 'function') {
                    const added = window.addPoints(1, GAME_ID);
                    if (added) {
                        // addPoints が成功したら必ずユーザー側の記録にも「今日付与済み」を残す
                        user.progress[levelKey][todayStr] = true;
                        users[currentUser] = user;
                        saveUsers(users);
                        return { status: 'awarded' };
                    } else {
                        return { status: 'failed' };
                    }
                } else {
                    // addPoints が存在しない（index側が古い等）
                    return { status: 'failed' };
                }
            }

            // データ（画像パスや単語）
            const ILLUSTRATION_PATH_PREFIX = 'assets/images/hiragana_words/';
            const ILLUSTRATION_PATH_SUFFIX = '.png'; 

            const gameLevels = [
                { level: 1, words: [ { hira: 'あめ', file: 'あめ' }, { hira: 'いぬ', file: 'いぬ' }, { hira: 'うし', file: 'うし' }, { hira: 'えび', file: 'えび' }, { hira: 'おに', file: 'おに' } ] },
                { level: 2, words: [ { hira: 'かに', file: 'かに' }, { hira: 'き', file: 'き' },{ hira: 'くるま', file: 'くるま' }, { hira: 'けむし', file: 'けむし' }, { hira: 'こま', file: 'こま' } ] },
                { level: 3, words: [ { hira: 'さる', file: 'さる' }, { hira: 'しか', file: 'しか' }, { hira: 'すし', file: 'すし' }, { hira: 'せみ', file: 'せみ' }, { hira: 'そば', file: 'そば' } ] },
                { level: 4, words: [ { hira: 'たこ', file: 'たこ' }, { hira: 'はち', file: 'はち' },{ hira: 'つき', file: 'つき' }, { hira: 'てれび', file: 'てれび' }, { hira: 'とり', file: 'とり' } ] },
                { level: 5, words: [ { hira: 'なす', file: 'なす' }, { hira: 'にほん', file: 'にほん' }, { hira: 'ぬの', file: 'ぬの' }, { hira: 'ねこ', file: 'ねこ' }, { hira: 'のり', file: 'のり' } ] },
                { level: 6, words: [ { hira: 'はし', file: 'はし' }, { hira: 'ひとで', file: 'ひとで' }, { hira: 'ふく', file: 'ふく' }, { hira: 'へび', file: 'へび' }, { hira: 'ほし', file: 'ほし' } ] },
                { level: 7, words: [ { hira: 'まくら', file: 'まくら' }, { hira: 'みかん', file: 'みかん' }, { hira: 'むぎ', file: 'むぎ' }, { hira: 'めだか', file: 'めだか' }, { hira: 'もも', file: 'もも' } ] },
                { level: 8, words: [ { hira: 'らくだ', file: 'らくだ' }, { hira: 'りんご', file: 'りんご' }, { hira: 'るんば', file: 'るんば' }, { hira: 'れもん', file: 'れもん' }, { hira: 'ろば', file: 'ろば' } ] },
                { level: 9, words: [ { hira: 'やぎ', file: 'やぎ' }, { hira: 'ゆかた', file: 'ゆかた' }, { hira: 'ようかい', file: 'ようかい' } ] },
                { level: 10, words: [ { hira: 'わに', file: 'わに' }, { hira: 'かばん', file: 'かばん' } ] }
            ];

            // DOM
            const mainTitleEl = document.getElementById('hg-main-title'); 
            const levelSelectionEl = document.getElementById('hg-level-selection');
            const levelTitleEl = document.getElementById('hg-level-title');
            const gameAreaEl = document.getElementById('hg-game-area');
            const illustPoolEl = document.getElementById('hg-illust-pool');
            const wordListEl = document.getElementById('hg-word-list');
            const feedbackEl = document.getElementById('hg-feedback');
            const resetPlacedButton = document.getElementById('hg-reset-placed-button');
            const homeButton = document.getElementById('hg-home-button'); 

            const soundCorrect = document.getElementById('hg-sound-correct');
            const soundIncorrect = document.getElementById('hg-sound-incorrect');

            let currentLevelData = null; 
            let currentLevelWords = [];

            function initGame() {
                gameLevels.forEach(levelData => {
                    const button = document.createElement('button');
                    button.textContent = `レベル ${levelData.level}`;
                    button.onclick = () => loadLevel(levelData);
                    levelSelectionEl.appendChild(button);
                });
                
                homeButton.onclick = () => {
                    window.location.href = 'index.html'; 
                };
            }
            
            function showLevelSelect() {
                gameAreaEl.style.display = 'none';
                levelTitleEl.textContent = '';
                feedbackEl.textContent = '';
                resetPlacedButton.style.display = 'none';
                
                levelSelectionEl.style.display = 'grid'; 
                mainTitleEl.style.display = 'block';

                homeButton.onclick = () => {
                    window.location.href = 'index.html';
                };
            }

            function loadLevel(levelData) {
                levelSelectionEl.style.display = 'none';
                mainTitleEl.style.display = 'none';
                
                currentLevelData = levelData; 
                currentLevelWords = levelData.words;
                
                const currentUser = getCurrentUser();
                let alreadyScored = false;
                
                if (currentUser) {
                    const users = getUsers();
                    const user = users[currentUser];
                    const levelKey = `${GAME_ID}_L${levelData.level}`;
                    const todayStr = getTodayDateString();
                    
                    if (user && user.progress && user.progress[levelKey] && user.progress[levelKey][todayStr] === true) {
                        alreadyScored = true;
                    }
                }
                
                let pointStatus = '';
                if (alreadyScored) {
                    pointStatus = ' (今日はポイント獲得済み)';
                } else if (!currentUser) {
                    pointStatus = ' (未ログイン/ゲスト: ポイント獲得不可)';
                }
                
                levelTitleEl.textContent = `レベル ${levelData.level} スタート！${pointStatus}`;
                
                feedbackEl.textContent = '';
                feedbackEl.classList.remove('success');
                gameAreaEl.style.display = 'flex';
                
                resetPlacedButton.style.display = 'none';
                illustPoolEl.innerHTML = '';
                wordListEl.innerHTML = '';

                const shuffledWords = shuffleArray([...currentLevelWords]);
                const shuffledIllusts = shuffleArray([...currentLevelWords]);

                shuffledWords.forEach(wordData => {
                    const row = document.createElement('div');
                    row.className = 'hg-word-row';
                    const dropTarget = document.createElement('div');
                    dropTarget.className = 'hg-drop-target';
                    dropTarget.dataset.word = wordData.hira; 
                    dropTarget.id = `hg-target-${wordData.hira}`; 
                    
                    const label = document.createElement('span');
                    label.className = 'hg-word-label';
                    label.textContent = wordData.hira;
                    row.appendChild(dropTarget);
                    row.appendChild(label);
                    wordListEl.appendChild(row);
                });

                shuffledIllusts.forEach(wordData => {
                    const item = document.createElement('div');
                    item.className = 'hg-drag-item';
                    
                    item.draggable = true; 
                    
                    item.dataset.word = wordData.hira;
                    item.id = `hg-item-${wordData.hira}`; 
                    item.dataset.initialParentId = 'hg-illust-pool';
                    
                    const img = document.createElement('img');
                    img.src = `${ILLUSTRATION_PATH_PREFIX}${wordData.file}${ILLUSTRATION_PATH_SUFFIX}`;
                    img.alt = wordData.hira;
                    img.draggable = false; 
                    item.appendChild(img);
                    illustPoolEl.appendChild(item);
                });

                addDragDropListeners();
            }
            
            function returnItemToPool(event) {
                const itemToReturn = event.currentTarget; 
                const parentTarget = itemToReturn.parentElement;

                illustPoolEl.appendChild(itemToReturn);
                itemToReturn.removeEventListener('click', returnItemToPool);

                if (parentTarget && parentTarget.classList.contains('hg-drop-target')) {
                    parentTarget.classList.remove('correct');
                    // drop target should be cleared
                    parentTarget.innerHTML = ''; 
                }

                feedbackEl.textContent = 'イラストをもどしました。';
                feedbackEl.classList.remove('success');
            }

            // ドラッグ&ドロップ（PC と タッチ両対応）
            let ghostItem = null;      
            let currentDragItem = null; 
            let lastTouchTarget = null; 

            function updateGhostPosition(touch) {
                if (!ghostItem) return;
                ghostItem.style.left = (touch.clientX - ghostItem.offsetWidth / 2) + 'px';
                ghostItem.style.top = (touch.clientY - ghostItem.offsetHeight / 2) + 'px';
            }

            function addDragDropListeners() {
                const dragItems = document.querySelectorAll('.hg-drag-item');
                const dropTargets = document.querySelectorAll('.hg-drop-target');
                
                const transparentImage = new Image();
                transparentImage.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; 
                
                dragItems.forEach(item => {
                    // PC マウス用
                    item.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', item.id);
                        if (e.dataTransfer && e.dataTransfer.setDragImage) {
                            e.dataTransfer.setDragImage(transparentImage, 0, 0);
                        }
                        setTimeout(() => item.style.opacity = '0.5', 0);
                    });
                    item.addEventListener('dragend', (e) => {
                        e.target.style.opacity = '1';
                    });

                    // クリックイベントの再設定
                    item.removeEventListener('click', returnItemToPool);
                    if (item.parentElement && item.parentElement.classList.contains('hg-drop-target')) {
                         item.addEventListener('click', returnItemToPool);
                         item.draggable = false;
                    } else {
                         item.draggable = true; 
                    }

                    // タッチ開始: 修正 => !item.draggable のときは無視（つまり draggableなら処理する）
                    item.addEventListener('touchstart', (e) => {
                        // 既にドラッグ中は無視
                        if (currentDragItem) return;

                        // 追加バリア: ドラッグ不可な時（既に配置済み）はタッチ操作をしない
                        if (!item.draggable) return;

                        currentDragItem = item; 
                        ghostItem = item.cloneNode(true);
                        ghostItem.classList.add('hg-touch-ghost'); 
                        document.body.appendChild(ghostItem);

                        item.style.opacity = '0.4';
                        updateGhostPosition(e.touches[0]);
                    }, { passive: true });
                });

                dropTargets.forEach(target => {
                    target.addEventListener('dragover', (e) => {
                        if (target.querySelector('.hg-drag-item')) return;
                        e.preventDefault();
                        target.classList.add('drag-over');
                    });
                    target.addEventListener('dragleave', () => {
                        target.classList.remove('drag-over');
                    });
                    target.addEventListener('drop', (e) => {
                        e.preventDefault();
                        target.classList.remove('drag-over');
                        if (target.querySelector('.hg-drag-item')) return;
                        
                        const dragItemId = e.dataTransfer.getData('text/plain');
                        const dragItem = document.getElementById(dragItemId);

                        if (dragItem) {
                            target.innerHTML = ''; 
                            target.appendChild(dragItem);
                            dragItem.draggable = false; 
                            dragItem.addEventListener('click', returnItemToPool);
                            checkFinalAnswers();
                        }
                    });
                });

                // タッチムーブ
                document.addEventListener('touchmove', (e) => {
                    if (!currentDragItem || !ghostItem) return;
                    e.preventDefault();
                    updateGhostPosition(e.touches[0]);

                    const touch = e.touches[0];
                    ghostItem.style.display = 'none'; 
                    const elementUnder = document.elementFromPoint(touch.clientX, touch.clientY);
                    ghostItem.style.display = ''; 

                    let currentTouchTarget = null;
                    if (elementUnder && (elementUnder.classList.contains('hg-drop-target') || elementUnder.parentElement?.classList.contains('hg-drop-target'))) {
                         currentTouchTarget = elementUnder.classList.contains('hg-drop-target') ? elementUnder : elementUnder.parentElement;
                    }

                    if (lastTouchTarget && lastTouchTarget !== currentTouchTarget) {
                        lastTouchTarget.classList.remove('drag-over');
                    }
                    if (currentTouchTarget && currentTouchTarget.classList.contains('hg-drop-target') && !currentTouchTarget.querySelector('.hg-drag-item')) {
                        currentTouchTarget.classList.add('drag-over');
                        lastTouchTarget = currentTouchTarget;
                    } else {
                        if (lastTouchTarget) lastTouchTarget.classList.remove('drag-over');
                        lastTouchTarget = null;
                    }

                }, { passive: false }); 

                // タッチエンド
                document.addEventListener('touchend', (e) => {
                    if (!currentDragItem || !ghostItem) return;

                    let dropTarget = lastTouchTarget; 
                    
                    if (dropTarget && !dropTarget.querySelector('.hg-drag-item')) {
                        dropTarget.classList.remove('drag-over');
                        dropTarget.innerHTML = ''; 
                        dropTarget.appendChild(currentDragItem); 
                        
                        currentDragItem.style.opacity = '1'; 
                        currentDragItem.draggable = false;
                        currentDragItem.addEventListener('click', returnItemToPool); 
                        
                        checkFinalAnswers();
                        
                    } else {
                        // 元の場所に戻す（プールにいるはず）
                        currentDragItem.style.opacity = '1'; 
                    }
                    
                    if (ghostItem && ghostItem.parentElement) {
                        document.body.removeChild(ghostItem);
                    } else if (ghostItem) {
                        try { document.body.removeChild(ghostItem); } catch (err) {}
                    }
                    ghostItem = null;
                    currentDragItem = null;
                    lastTouchTarget = null;
                });
            }

            function checkFinalAnswers() {
                const dropTargets = document.querySelectorAll('.hg-drop-target');
                const totalTargets = currentLevelWords.length;
                let filledCount = 0;
                let allCorrect = true;

                dropTargets.forEach(target => {
                    if (target.querySelector('.hg-drag-item')) {
                        filledCount++;
                    }
                });

                if (filledCount < totalTargets) {
                    feedbackEl.textContent = `あと ${totalTargets - filledCount} こ。`;
                    feedbackEl.classList.remove('success');
                    return; 
                }

                dropTargets.forEach(target => {
                    const placedItem = target.querySelector('.hg-drag-item');
                    const targetWord = target.dataset.word;
                    const placedWord = placedItem.dataset.word;
                    
                    if (targetWord !== placedWord) {
                        allCorrect = false; 
                    }
                });

                if (allCorrect) {
                    soundCorrect.currentTime = 0;
                    soundCorrect.play();
                    
                    dropTargets.forEach(target => {
                         target.classList.add('correct');
                         const placedItem = target.querySelector('.hg-drag-item');
                         if (placedItem) {
                             placedItem.removeEventListener('click', returnItemToPool);
                             placedItem.style.cursor = 'not-allowed'; 
                         }
                    });
                    
                    // ポイント処理（改良版）
                    const level = currentLevelData.level;
                    const result = checkAndRecordScore(level);

                    let message = 'おめでとうございます！ぜんぶせいかい！';
                    if (result.status === 'awarded') {
                        message += ' (+1 ポイント獲得！)';
                    } else if (result.status === 'already') {
                        message += ' (今日はポイント獲得済み)';
                    } else if (result.status === 'no_user') {
                        message += ' (未ログインのためポイントは付与されません)';
                    } else {
                        message += ' (ポイント処理に失敗しました)';
                    }

                    feedbackEl.textContent = message;
                    feedbackEl.classList.add('success');
                    
                    levelTitleEl.textContent = 'レベルクリア！';
                    resetPlacedButton.style.display = 'none'; 
                    
                    const currentLevelIndex = gameLevels.findIndex(lvl => lvl.level === currentLevelData.level);
                    const nextLevelIndex = currentLevelIndex + 1;
                    
                    if (nextLevelIndex < gameLevels.length) {
                        const nextLevelData = gameLevels[nextLevelIndex];
                        levelTitleEl.textContent = `レベルクリア！ ${nextLevelData.level} にすすむよ！`;
                        setTimeout(() => {
                            loadLevel(nextLevelData);
                        }, 2000); 
                    } else {
                        levelTitleEl.textContent = 'ぜんぶクリア！';
                        feedbackEl.textContent = message;
                    }
                    
                } else {
                    soundIncorrect.currentTime = 0;
                    soundIncorrect.play();
                    
                    feedbackEl.textContent = 'ちがうところがあるよ。まちがっているイラストをクリックして、もどしてね。';
                    feedbackEl.classList.remove('success');
                }
            }

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            initGame();
        });
    </script>

</body>
</html>
